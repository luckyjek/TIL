// 함수내부에서 외부로부터 주어진 인자의 값을 변경하는 것은 💩
// 상태변경이 필요한 경우에는, 새로운 상태를 (오브젝트, 값) 만들어서 반환해야 함 ✨
// 왜냐? 원시값을 그렇게 큰 문제가 없지만, 객체값을 큰 문제가된다.
// 원시값 - 값에 의한 복사 (큰 문제가 되지는 않지만 객체에서 문제가됨)
// 객체값 - 참조에 의한 복사 (메모리주소)
function display(num){
    num = 5; //❌ <- 외부에서 받아온 값을 내부에서 변경하는것은 정말 좋지않다. 즉 함수에 인자로 들어오는 인자값을 재할당 하지마라.
    console.log(num);
}

const value = 4; //원시값은 전달되거나, 할당 될 떄 값에 의해서 `복사`가된다.
display(value);
console.log(value);

//--------------------------------

function displayObj(obj){
    //보여준다고만 하는 함수인데, 갑자기 엉뚱하게 내부에서 name을 바꾼다면 ? 
    obj.name = 'Bob'; // ❌❌❌❌❌❌❌❌ 함수 내부에서 외부로 부터 전달된 인자의 값을 (특히 오브젝트✨)변경하는 것은 정말 나쁜짓!❌
    console.log(obj); //{ name: 'Bob' }
}

const elin = {name: 'Elin'}; //값 자체가 아닌, 주소값이 전달된다.
displayObj(elin); //따라서 다른곳에 쓰여지는 값들도 전부 다 {name: 'Bob'} 으로 바뀐다.


// 따라서 정~말 부득이하게 무언가 주어진 인자로부터 상태를 변경해야된다면, 
// 함수 이름부터 변경한다는 느낌의 뉘앙스가 나오도록 만들어줘야한다. -> 즉, 변경한다는'것'을 명확하게 명시해준다. changeName()
// 그리고 전달된 object를 obj.name = 'Bob'; 처럼 그대로 바꾸는 것이다니라. 아래와같이한다.
function changeName(obj){ 
    // 오브젝트 리터럴을 쓰는 순간, 새로운 object를 만든다.
    // 따라서 기존의 ...obj를 그대로 유지하면서,  새로 name만 변경하고자한다면 name:'Bob'과 같이 쓴다.
    return {...obj, name: 'Bob'}; // 반환할때는 새로운 오브젝트 만들기!
}

// 따라서 Immutability를 정리하자면? (배열편에서 다시 언급)
// 1. 이름부터 변경하는 느낌을 주도록!
// 2. 반환할때는 새로운 오브젝트 만들기!

// point : 
// 1. 함수에 인자로 들어오는 인자값을 재할당 하지마라. -> 함수 내부에서는 주어진 값을 가지고 지지고볶고 하다가 새로운 값을 return해야한다.
 